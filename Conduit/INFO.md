# Service Mesh Architecture
The most complex problems that microservice professionals have are networking and observability. that is, how do services communicate reliably? When things go wrong, how can you quickly solve the problem and fix it or fix it? The interconnection and reliable observation of the microservice requires a multitude of techniques that include service discovery, load balancing, waiting times, retries, automatic switches, status verification, advanced routing, statistics, registration, distributed tracking and more. Historically, most modern architectures have been libraries with many functions in each language that the organization uses to address these concerns. This, by definition, needs to redeploy and maintain a large number of sophisticated functionalities in multiple languages.

**The idea behind the "service mesh" is to use an out-of-process proxy "sidecar" that runs in conjunction with each application**

The service mesh consists of a data plane where all the service-to-service communication is produced through the sidecar servers. (The interconnections of all proxies form a mesh, hence the name.) The mesh also consists of a control plane, which links all independent sidecar proxies in a distributed network and sets the policies promulgated by the data plane.

The control plane is in the various areas for service discovery, routing, traffic control, etc. The data plane is responsible for making and enforcing these policies when communicating.

Once service meshes intercept all service-service communication, they can encrypt and authenticate all communications without programmer participation (great advantage) and can also access authorization policies for who can call who. Since all traffic flows through the data plane of the service mesh, the service mesh can guarantee the encryption of all supported protocols / allow / reject the exit / entry for each service.

Once the orchestration is implemented by, for example, **Kubernetes**, the approaches of the traditional segmentation of the red begin to decompose. The service mesh allows services to recover a consistent and secure form of identity within a data center and, in addition, to do so based on strong cryptographic primitives instead of an implementation topology. Conduit, for example, can provide and / or integrate with the certification authority to automate the distribution of TLS credentials for services, so that when communicating mesh-enabled services, they have a strong cryptographic test of their peers. Once these identity primitives are established, they can be used to build access control policies.

Fundamentally, a sidecar is just another container. With sidecar proxies, we can manage the operational logic as close as possible to the application, without really being inside the application code. The objective of a service network is to decouple its applications from the aspects related to the management of communication of services in an effective and reliable way. With the sidecar pattern, we can do things to provide and validate the identity for the applications, since the sidecar has the same level of privileges of the service for which it is provisioned. That is the biggest difference between sidecars vs eg implementations per host.
